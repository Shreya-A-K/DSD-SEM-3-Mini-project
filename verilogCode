`timescale 1ns/1ps

// -------------------- Comparator --------------------
module comparator_16bit (
    input  [15:0] A,   // Entered password
    input  [15:0] B,   // Stored password
    output        A_eq_B
);
    assign A_eq_B = (A == B);
endmodule

// -------------------- Seven Segment Decoder --------------------
module seven_seg_decoder (
    input  [3:0] bin,
    output reg [6:0] seg  // {a,b,c,d,e,f,g}
);
    always @(*) begin
        case (bin)
            4'b0000: seg = 7'b0000001; // 0
            4'b0001: seg = 7'b1001111; // 1
            4'b0010: seg = 7'b0010010; // 2
            4'b0011: seg = 7'b0000110; // 3
            4'b0100: seg = 7'b1001100; // 4
            4'b0101: seg = 7'b0100100; // 5
            4'b0110: seg = 7'b0100000; // 6
            4'b0111: seg = 7'b0001111; // 7
            4'b1000: seg = 7'b0000000; // 8
            4'b1001: seg = 7'b0000100; // 9
            default: seg = 7'b1111111; // off
        endcase
    end
endmodule

// -------------------- Top Module --------------------
module password_lock (
    input  [15:0] A,   // Entered 4-digit password
    input  [15:0] B,   // Stored 4-digit password
    output [6:0] segA0, segA1, segA2, segA3, // Entered password digits
    output [6:0] segB0, segB1, segB2, segB3, // Stored password digits
    output [6:0] segL0, segL1, segL2, segL3, // Lock status ("OPEN"/"CLOS")
    output        LOCK_OPEN
);

    // Comparator
    comparator_16bit cmp (
        .A(A),
        .B(B),
        .A_eq_B(LOCK_OPEN)
    );

    // Display Entered Password
    seven_seg_decoder dA0 (.bin(A[3:0]),   .seg(segA0));
    seven_seg_decoder dA1 (.bin(A[7:4]),   .seg(segA1));
    seven_seg_decoder dA2 (.bin(A[11:8]),  .seg(segA2));
    seven_seg_decoder dA3 (.bin(A[15:12]), .seg(segA3));

    // Display Stored Password
    seven_seg_decoder dB0 (.bin(B[3:0]),   .seg(segB0));
    seven_seg_decoder dB1 (.bin(B[7:4]),   .seg(segB1));
    seven_seg_decoder dB2 (.bin(B[11:8]),  .seg(segB2));
    seven_seg_decoder dB3 (.bin(B[15:12]), .seg(segB3));

    // Display Lock Status
    // For simplicity: just show "OPEN" if correct, else "CLOS"
    assign segL0 = (LOCK_OPEN) ? 7'b0001000 : 7'b0100000; // O / C
    assign segL1 = (LOCK_OPEN) ? 7'b0001100 : 7'b1000110; // P / L
    assign segL2 = (LOCK_OPEN) ? 7'b0000110 : 7'b1000000; // E / O
    assign segL3 = (LOCK_OPEN) ? 7'b0101011 : 7'b0010010; // N / S

endmodule

// -------------------- Testbench --------------------
module tb_password_lock;

    reg  [15:0] A;
    reg  [15:0] B;
    wire [6:0] segA0, segA1, segA2, segA3;
    wire [6:0] segB0, segB1, segB2, segB3;
    wire [6:0] segL0, segL1, segL2, segL3;
    wire LOCK_OPEN;

    // Intermediate for monitoring
    wire lock_status;
    assign lock_status = LOCK_OPEN;

    // Instantiate the top module
    password_lock uut (
        .A(A), .B(B),
        .segA0(segA0), .segA1(segA1), .segA2(segA2), .segA3(segA3),
        .segB0(segB0), .segB1(segB1), .segB2(segB2), .segB3(segB3),
        .segL0(segL0), .segL1(segL1), .segL2(segL2), .segL3(segL3),
        .LOCK_OPEN(LOCK_OPEN)
    );

    initial begin
        $monitor("Time=%0t | Entered=%h Stored=%h | LOCK=%b",
                  $time, A, B, lock_status);

        // Stored password = 1234 (in BCD → 0001 0010 0011 0100)
        B = 16'b0001_0010_0011_0100;

        // Test 1: Entered = 1234 → OPEN
        A = 16'b0001_0010_0011_0100; #10;

        // Test 2: Entered = 5678 → CLOSED
        A = 16'b0101_0110_0111_1000; #10;

        // Test 3: Entered = 1111 → CLOSED
        A = 16'b0001_0001_0001_0001; #10;

        // Test 4: Entered = 4321 → CLOSED
        A = 16'b0100_0011_0010_0001; #10;

        // Test 5: Entered = 1234 → OPEN again
        A = 16'b0001_0010_0011_0100; #10;

        $finish;
    end

endmodule
